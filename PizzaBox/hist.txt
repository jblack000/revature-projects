    1  git remote add upstream https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
    2  git push --set-upstream https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git master
    3  git push --set-upstream https://github.com/revaturexyz/challenge-employeedb-jblack000-1 master
    4  git push https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
    5  git push --set-upstream https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git master
    6  git remote rename origin upstream
    7  git remote add origin https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
    8  git push origin master
    9  git push
   10  git push --set-upstream origin master
   11  git push
   12  git push -u https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
   13  git push -u origin master
   14  git push -u origin
   15  git push -u https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git master
   16  git remote add https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
   17  git remote add origin https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
   18  git push
   19  git push origin master
   20  git push -u origin master
   21  git push -u https://github.com/revaturexyz/challenge-employeedb-jblack000-1/master
   22  git push -u https://github.com/revaturexyz/challenge-employeedb-jblack000-1/.git/master
   23  git push -u https://github.com/revaturexyz/challenge-employeedb-jblack000-1/upload/master
   24  git remote -v
   25  git push origin master
   26  git push
   27  git push origin
   28  git push origin master
   29  git push -u https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git master
   30  git push master
   31  git push -u https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
   32  git push https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
   33  git push
   34  git push --set-upstream https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
   35  git push --set-upstream https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git master
   36  git push --set-upstream 'https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git' master
   37  git push
   38  git push https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git master
   39  git branch -u https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git master
   40  git push https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
   41  git push -u origin
   42  git -v
   43  git pull
   44  git push -u https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git master
   45  git push -u origin https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
   46  git push origin https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
   47  git add origin
   48  git remote add
   49  git remote add origin
   50  git remote add https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
   51  git remote add origin https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
   52  git push
   53  git remote -v
   54  git push --force origin master
   55  git push -u master
   56  git push -u https://github.com/revaturexyz/challenge-employeedb-jblack000-1.git
   57  #!/bin/bash
   58  trap '[ "$?" -eq 0 ] || read -p "Looks like something went wrong in step ´$STEP´... Press any key to continue..."' EXIT
   59  #Quick Hack: used to convert e.g. "C:\Program Files\Docker Toolbox" to "/c/Program Files/Docker Toolbox"
   60  win_to_unix_path(){  	wd="$(pwd)"; 	cd "$1"; 		the_path="$(pwd)"; 	cd "$wd"; 	echo $the_path; }
   61  # This is needed  to ensure that binaries provided
   62  # by Docker Toolbox over-ride binaries provided by
   63  # Docker for Windows when launching using the Quickstart.
   64  export PATH="$(win_to_unix_path "${DOCKER_TOOLBOX_INSTALL_PATH}"):$PATH"
   65  VM=${DOCKER_MACHINE_NAME-default}
   66  DOCKER_MACHINE="${DOCKER_TOOLBOX_INSTALL_PATH}\docker-machine.exe"
   67  STEP="Looking for vboxmanage.exe"
   68  if [ ! -z "$VBOX_MSI_INSTALL_PATH" ]; then   VBOXMANAGE="${VBOX_MSI_INSTALL_PATH}VBoxManage.exe"; else   VBOXMANAGE="${VBOX_INSTALL_PATH}VBoxManage.exe"; fi
   69  BLUE='\033[1;34m'
   70  GREEN='\033[0;32m'
   71  NC='\033[0m'
   72  #clear all_proxy if not socks address
   73  if  [[ $ALL_PROXY != socks* ]]; then   unset ALL_PROXY; fi
   74  if  [[ $all_proxy != socks* ]]; then   unset all_proxy; fi
   75  if [ ! -f "${DOCKER_MACHINE}" ]; then   echo "Docker Machine is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
   76  if [ ! -f "${VBOXMANAGE}" ]; then   echo "VirtualBox is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
   77  "${VBOXMANAGE}" list vms | grep \""${VM}"\" &> /dev/null
   78  VM_EXISTS_CODE=$?
   79  set -e
   80  STEP="Checking if machine $VM exists"
   81  if [ $VM_EXISTS_CODE -eq 1 ]; then   "${DOCKER_MACHINE}" rm -f "${VM}" &> /dev/null || :;   rm -rf ~/.docker/machine/machines/"${VM}"   if [ "${HTTP_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTP_PROXY=$HTTP_PROXY";   fi;   if [ "${HTTPS_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTPS_PROXY=$HTTPS_PROXY";   fi;   if [ "${NO_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env NO_PROXY=$NO_PROXY";   fi;   "${DOCKER_MACHINE}" create -d virtualbox $PROXY_ENV "${VM}"; fi
   82  STEP="Checking status on $VM"
   83  VM_STATUS="$( set +e ; "${DOCKER_MACHINE}" status "${VM}" )"
   84  if [ "${VM_STATUS}" != "Running" ]; then   "${DOCKER_MACHINE}" start "${VM}";   yes | "${DOCKER_MACHINE}" regenerate-certs "${VM}"; fi
   85  STEP="Setting env"
   86  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}" | sed -e "s/export/SETX/g" | sed -e "s/=/ /g")" &> /dev/null #for persistent Environment Variables, available in next sessions
   87  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}")" #for transient Environment Variables, available in current session
   88  STEP="Finalize"
   89  clear
   90  cat << EOF
   91                          ##         .
   92                    ## ## ##        ==
   93                 ## ## ## ## ##    ===
   94             /"""""""""""""""""\___/ ===
   95        ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
   96             \______ o           __/
   97               \    \         __/
   98                \____\_______/
   99  EOF
  100  echo -e "${BLUE}docker${NC} is configured to use the ${GREEN}${VM}${NC} machine with IP ${GREEN}$("${DOCKER_MACHINE}" ip ${VM})${NC}"
  101  echo "For help getting started, check out the docs at https://docs.docker.com"
  102  echo
  103  echo 
  104  #cd #Bad: working dir should be whatever directory was invoked from rather than fixed to the Home folder
  105  docker () {   MSYS_NO_PATHCONV=1 docker.exe "$@"; }
  106  export -f docker
  107  if [ $# -eq 0 ]; then   echo "Start interactive shell";   exec "$BASH" --login -i; else   echo "Start shell with command";   exec "$BASH" -c "$*"; fi
  108  #!/bin/bash
  109  trap '[ "$?" -eq 0 ] || read -p "Looks like something went wrong in step ´$STEP´... Press any key to continue..."' EXIT
  110  #Quick Hack: used to convert e.g. "C:\Program Files\Docker Toolbox" to "/c/Program Files/Docker Toolbox"
  111  win_to_unix_path(){  	wd="$(pwd)"; 	cd "$1"; 		the_path="$(pwd)"; 	cd "$wd"; 	echo $the_path; }
  112  # This is needed  to ensure that binaries provided
  113  # by Docker Toolbox over-ride binaries provided by
  114  # Docker for Windows when launching using the Quickstart.
  115  export PATH="$(win_to_unix_path "${DOCKER_TOOLBOX_INSTALL_PATH}"):$PATH"
  116  VM=${DOCKER_MACHINE_NAME-default}
  117  DOCKER_MACHINE="${DOCKER_TOOLBOX_INSTALL_PATH}\docker-machine.exe"
  118  STEP="Looking for vboxmanage.exe"
  119  if [ ! -z "$VBOX_MSI_INSTALL_PATH" ]; then   VBOXMANAGE="${VBOX_MSI_INSTALL_PATH}VBoxManage.exe"; else   VBOXMANAGE="${VBOX_INSTALL_PATH}VBoxManage.exe"; fi
  120  BLUE='\033[1;34m'
  121  GREEN='\033[0;32m'
  122  NC='\033[0m'
  123  #clear all_proxy if not socks address
  124  if  [[ $ALL_PROXY != socks* ]]; then   unset ALL_PROXY; fi
  125  if  [[ $all_proxy != socks* ]]; then   unset all_proxy; fi
  126  if [ ! -f "${DOCKER_MACHINE}" ]; then   echo "Docker Machine is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  127  if [ ! -f "${VBOXMANAGE}" ]; then   echo "VirtualBox is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  128  "${VBOXMANAGE}" list vms | grep \""${VM}"\" &> /dev/null
  129  VM_EXISTS_CODE=$?
  130  set -e
  131  STEP="Checking if machine $VM exists"
  132  if [ $VM_EXISTS_CODE -eq 1 ]; then   "${DOCKER_MACHINE}" rm -f "${VM}" &> /dev/null || :;   rm -rf ~/.docker/machine/machines/"${VM}"   if [ "${HTTP_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTP_PROXY=$HTTP_PROXY";   fi;   if [ "${HTTPS_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTPS_PROXY=$HTTPS_PROXY";   fi;   if [ "${NO_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env NO_PROXY=$NO_PROXY";   fi;   "${DOCKER_MACHINE}" create -d virtualbox $PROXY_ENV "${VM}"; fi
  133  STEP="Checking status on $VM"
  134  VM_STATUS="$( set +e ; "${DOCKER_MACHINE}" status "${VM}" )"
  135  if [ "${VM_STATUS}" != "Running" ]; then   "${DOCKER_MACHINE}" start "${VM}";   yes | "${DOCKER_MACHINE}" regenerate-certs "${VM}"; fi
  136  STEP="Setting env"
  137  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}" | sed -e "s/export/SETX/g" | sed -e "s/=/ /g")" &> /dev/null #for persistent Environment Variables, available in next sessions
  138  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}")" #for transient Environment Variables, available in current session
  139  STEP="Finalize"
  140  clear
  141  cat << EOF
  142                          ##         .
  143                    ## ## ##        ==
  144                 ## ## ## ## ##    ===
  145             /"""""""""""""""""\___/ ===
  146        ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
  147             \______ o           __/
  148               \    \         __/
  149                \____\_______/
  150  EOF
  151  echo -e "${BLUE}docker${NC} is configured to use the ${GREEN}${VM}${NC} machine with IP ${GREEN}$("${DOCKER_MACHINE}" ip ${VM})${NC}"
  152  echo "For help getting started, check out the docs at https://docs.docker.com"
  153  echo
  154  echo 
  155  #cd #Bad: working dir should be whatever directory was invoked from rather than fixed to the Home folder
  156  docker () {   MSYS_NO_PATHCONV=1 docker.exe "$@"; }
  157  export -f docker
  158  if [ $# -eq 0 ]; then   echo "Start interactive shell";   exec "$BASH" --login -i; else   echo "Start shell with command";   exec "$BASH" -c "$*"; fi
  159  #!/bin/bash
  160  trap '[ "$?" -eq 0 ] || read -p "Looks like something went wrong in step ´$STEP´... Press any key to continue..."' EXIT
  161  #Quick Hack: used to convert e.g. "C:\Program Files\Docker Toolbox" to "/c/Program Files/Docker Toolbox"
  162  win_to_unix_path(){  	wd="$(pwd)"; 	cd "$1"; 		the_path="$(pwd)"; 	cd "$wd"; 	echo $the_path; }
  163  # This is needed  to ensure that binaries provided
  164  # by Docker Toolbox over-ride binaries provided by
  165  # Docker for Windows when launching using the Quickstart.
  166  export PATH="$(win_to_unix_path "${DOCKER_TOOLBOX_INSTALL_PATH}"):$PATH"
  167  VM=${DOCKER_MACHINE_NAME-default}
  168  DOCKER_MACHINE="${DOCKER_TOOLBOX_INSTALL_PATH}\docker-machine.exe"
  169  STEP="Looking for vboxmanage.exe"
  170  if [ ! -z "$VBOX_MSI_INSTALL_PATH" ]; then   VBOXMANAGE="${VBOX_MSI_INSTALL_PATH}VBoxManage.exe"; else   VBOXMANAGE="${VBOX_INSTALL_PATH}VBoxManage.exe"; fi
  171  BLUE='\033[1;34m'
  172  GREEN='\033[0;32m'
  173  NC='\033[0m'
  174  #clear all_proxy if not socks address
  175  if  [[ $ALL_PROXY != socks* ]]; then   unset ALL_PROXY; fi
  176  if  [[ $all_proxy != socks* ]]; then   unset all_proxy; fi
  177  if [ ! -f "${DOCKER_MACHINE}" ]; then   echo "Docker Machine is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  178  if [ ! -f "${VBOXMANAGE}" ]; then   echo "VirtualBox is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  179  "${VBOXMANAGE}" list vms | grep \""${VM}"\" &> /dev/null
  180  VM_EXISTS_CODE=$?
  181  set -e
  182  STEP="Checking if machine $VM exists"
  183  if [ $VM_EXISTS_CODE -eq 1 ]; then   "${DOCKER_MACHINE}" rm -f "${VM}" &> /dev/null || :;   rm -rf ~/.docker/machine/machines/"${VM}"   if [ "${HTTP_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTP_PROXY=$HTTP_PROXY";   fi;   if [ "${HTTPS_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTPS_PROXY=$HTTPS_PROXY";   fi;   if [ "${NO_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env NO_PROXY=$NO_PROXY";   fi;   "${DOCKER_MACHINE}" create -d virtualbox $PROXY_ENV "${VM}"; fi
  184  STEP="Checking status on $VM"
  185  VM_STATUS="$( set +e ; "${DOCKER_MACHINE}" status "${VM}" )"
  186  if [ "${VM_STATUS}" != "Running" ]; then   "${DOCKER_MACHINE}" start "${VM}";   yes | "${DOCKER_MACHINE}" regenerate-certs "${VM}"; fi
  187  STEP="Setting env"
  188  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}" | sed -e "s/export/SETX/g" | sed -e "s/=/ /g")" &> /dev/null #for persistent Environment Variables, available in next sessions
  189  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}")" #for transient Environment Variables, available in current session
  190  STEP="Finalize"
  191  clear
  192  cat << EOF
  193                          ##         .
  194                    ## ## ##        ==
  195                 ## ## ## ## ##    ===
  196             /"""""""""""""""""\___/ ===
  197        ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
  198             \______ o           __/
  199               \    \         __/
  200                \____\_______/
  201  EOF
  202  echo -e "${BLUE}docker${NC} is configured to use the ${GREEN}${VM}${NC} machine with IP ${GREEN}$("${DOCKER_MACHINE}" ip ${VM})${NC}"
  203  echo "For help getting started, check out the docs at https://docs.docker.com"
  204  echo
  205  echo 
  206  #cd #Bad: working dir should be whatever directory was invoked from rather than fixed to the Home folder
  207  docker () {   MSYS_NO_PATHCONV=1 docker.exe "$@"; }
  208  export -f docker
  209  if [ $# -eq 0 ]; then   echo "Start interactive shell";   exec "$BASH" --login -i; else   echo "Start shell with command";   exec "$BASH" -c "$*"; fi
  210  #!/bin/bash
  211  trap '[ "$?" -eq 0 ] || read -p "Looks like something went wrong in step ´$STEP´... Press any key to continue..."' EXIT
  212  #Quick Hack: used to convert e.g. "C:\Program Files\Docker Toolbox" to "/c/Program Files/Docker Toolbox"
  213  win_to_unix_path(){  	wd="$(pwd)"; 	cd "$1"; 		the_path="$(pwd)"; 	cd "$wd"; 	echo $the_path; }
  214  # This is needed  to ensure that binaries provided
  215  # by Docker Toolbox over-ride binaries provided by
  216  # Docker for Windows when launching using the Quickstart.
  217  export PATH="$(win_to_unix_path "${DOCKER_TOOLBOX_INSTALL_PATH}"):$PATH"
  218  VM=${DOCKER_MACHINE_NAME-default}
  219  DOCKER_MACHINE="${DOCKER_TOOLBOX_INSTALL_PATH}\docker-machine.exe"
  220  STEP="Looking for vboxmanage.exe"
  221  if [ ! -z "$VBOX_MSI_INSTALL_PATH" ]; then   VBOXMANAGE="${VBOX_MSI_INSTALL_PATH}VBoxManage.exe"; else   VBOXMANAGE="${VBOX_INSTALL_PATH}VBoxManage.exe"; fi
  222  BLUE='\033[1;34m'
  223  GREEN='\033[0;32m'
  224  NC='\033[0m'
  225  #clear all_proxy if not socks address
  226  if  [[ $ALL_PROXY != socks* ]]; then   unset ALL_PROXY; fi
  227  if  [[ $all_proxy != socks* ]]; then   unset all_proxy; fi
  228  if [ ! -f "${DOCKER_MACHINE}" ]; then   echo "Docker Machine is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  229  if [ ! -f "${VBOXMANAGE}" ]; then   echo "VirtualBox is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  230  "${VBOXMANAGE}" list vms | grep \""${VM}"\" &> /dev/null
  231  VM_EXISTS_CODE=$?
  232  set -e
  233  STEP="Checking if machine $VM exists"
  234  if [ $VM_EXISTS_CODE -eq 1 ]; then   "${DOCKER_MACHINE}" rm -f "${VM}" &> /dev/null || :;   rm -rf ~/.docker/machine/machines/"${VM}"   if [ "${HTTP_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTP_PROXY=$HTTP_PROXY";   fi;   if [ "${HTTPS_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTPS_PROXY=$HTTPS_PROXY";   fi;   if [ "${NO_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env NO_PROXY=$NO_PROXY";   fi;   "${DOCKER_MACHINE}" create -d virtualbox $PROXY_ENV "${VM}"; fi
  235  STEP="Checking status on $VM"
  236  VM_STATUS="$( set +e ; "${DOCKER_MACHINE}" status "${VM}" )"
  237  if [ "${VM_STATUS}" != "Running" ]; then   "${DOCKER_MACHINE}" start "${VM}";   yes | "${DOCKER_MACHINE}" regenerate-certs "${VM}"; fi
  238  STEP="Setting env"
  239  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}" | sed -e "s/export/SETX/g" | sed -e "s/=/ /g")" &> /dev/null #for persistent Environment Variables, available in next sessions
  240  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}")" #for transient Environment Variables, available in current session
  241  STEP="Finalize"
  242  clear
  243  cat << EOF
  244                          ##         .
  245                    ## ## ##        ==
  246                 ## ## ## ## ##    ===
  247             /"""""""""""""""""\___/ ===
  248        ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
  249             \______ o           __/
  250               \    \         __/
  251                \____\_______/
  252  EOF
  253  echo -e "${BLUE}docker${NC} is configured to use the ${GREEN}${VM}${NC} machine with IP ${GREEN}$("${DOCKER_MACHINE}" ip ${VM})${NC}"
  254  echo "For help getting started, check out the docs at https://docs.docker.com"
  255  echo
  256  echo 
  257  #cd #Bad: working dir should be whatever directory was invoked from rather than fixed to the Home folder
  258  docker () {   MSYS_NO_PATHCONV=1 docker.exe "$@"; }
  259  export -f docker
  260  if [ $# -eq 0 ]; then   echo "Start interactive shell";   exec "$BASH" --login -i; else   echo "Start shell with command";   exec "$BASH" -c "$*"; fi
  261  #!/bin/bash
  262  trap '[ "$?" -eq 0 ] || read -p "Looks like something went wrong in step ´$STEP´... Press any key to continue..."' EXIT
  263  #Quick Hack: used to convert e.g. "C:\Program Files\Docker Toolbox" to "/c/Program Files/Docker Toolbox"
  264  win_to_unix_path(){  	wd="$(pwd)"; 	cd "$1"; 		the_path="$(pwd)"; 	cd "$wd"; 	echo $the_path; }
  265  # This is needed  to ensure that binaries provided
  266  # by Docker Toolbox over-ride binaries provided by
  267  # Docker for Windows when launching using the Quickstart.
  268  export PATH="$(win_to_unix_path "${DOCKER_TOOLBOX_INSTALL_PATH}"):$PATH"
  269  VM=${DOCKER_MACHINE_NAME-default}
  270  DOCKER_MACHINE="${DOCKER_TOOLBOX_INSTALL_PATH}\docker-machine.exe"
  271  STEP="Looking for vboxmanage.exe"
  272  if [ ! -z "$VBOX_MSI_INSTALL_PATH" ]; then   VBOXMANAGE="${VBOX_MSI_INSTALL_PATH}VBoxManage.exe"; else   VBOXMANAGE="${VBOX_INSTALL_PATH}VBoxManage.exe"; fi
  273  BLUE='\033[1;34m'
  274  GREEN='\033[0;32m'
  275  NC='\033[0m'
  276  #clear all_proxy if not socks address
  277  if  [[ $ALL_PROXY != socks* ]]; then   unset ALL_PROXY; fi
  278  if  [[ $all_proxy != socks* ]]; then   unset all_proxy; fi
  279  if [ ! -f "${DOCKER_MACHINE}" ]; then   echo "Docker Machine is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  280  if [ ! -f "${VBOXMANAGE}" ]; then   echo "VirtualBox is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  281  "${VBOXMANAGE}" list vms | grep \""${VM}"\" &> /dev/null
  282  VM_EXISTS_CODE=$?
  283  set -e
  284  STEP="Checking if machine $VM exists"
  285  if [ $VM_EXISTS_CODE -eq 1 ]; then   "${DOCKER_MACHINE}" rm -f "${VM}" &> /dev/null || :;   rm -rf ~/.docker/machine/machines/"${VM}"   if [ "${HTTP_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTP_PROXY=$HTTP_PROXY";   fi;   if [ "${HTTPS_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTPS_PROXY=$HTTPS_PROXY";   fi;   if [ "${NO_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env NO_PROXY=$NO_PROXY";   fi;   "${DOCKER_MACHINE}" create -d virtualbox $PROXY_ENV "${VM}"; fi
  286  STEP="Checking status on $VM"
  287  VM_STATUS="$( set +e ; "${DOCKER_MACHINE}" status "${VM}" )"
  288  if [ "${VM_STATUS}" != "Running" ]; then   "${DOCKER_MACHINE}" start "${VM}";   yes | "${DOCKER_MACHINE}" regenerate-certs "${VM}"; fi
  289  STEP="Setting env"
  290  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}" | sed -e "s/export/SETX/g" | sed -e "s/=/ /g")" &> /dev/null #for persistent Environment Variables, available in next sessions
  291  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}")" #for transient Environment Variables, available in current session
  292  STEP="Finalize"
  293  clear
  294  cat << EOF
  295                          ##         .
  296                    ## ## ##        ==
  297                 ## ## ## ## ##    ===
  298             /"""""""""""""""""\___/ ===
  299        ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
  300             \______ o           __/
  301               \    \         __/
  302                \____\_______/
  303  EOF
  304  echo -e "${BLUE}docker${NC} is configured to use the ${GREEN}${VM}${NC} machine with IP ${GREEN}$("${DOCKER_MACHINE}" ip ${VM})${NC}"
  305  echo "For help getting started, check out the docs at https://docs.docker.com"
  306  echo
  307  echo 
  308  #cd #Bad: working dir should be whatever directory was invoked from rather than fixed to the Home folder
  309  docker () {   MSYS_NO_PATHCONV=1 docker.exe "$@"; }
  310  export -f docker
  311  if [ $# -eq 0 ]; then   echo "Start interactive shell";   exec "$BASH" --login -i; else   echo "Start shell with command";   exec "$BASH" -c "$*"; fi
  312  #!/bin/bash
  313  trap '[ "$?" -eq 0 ] || read -p "Looks like something went wrong in step ´$STEP´... Press any key to continue..."' EXIT
  314  #Quick Hack: used to convert e.g. "C:\Program Files\Docker Toolbox" to "/c/Program Files/Docker Toolbox"
  315  win_to_unix_path(){  	wd="$(pwd)"; 	cd "$1"; 		the_path="$(pwd)"; 	cd "$wd"; 	echo $the_path; }
  316  # This is needed  to ensure that binaries provided
  317  # by Docker Toolbox over-ride binaries provided by
  318  # Docker for Windows when launching using the Quickstart.
  319  export PATH="$(win_to_unix_path "${DOCKER_TOOLBOX_INSTALL_PATH}"):$PATH"
  320  VM=${DOCKER_MACHINE_NAME-default}
  321  DOCKER_MACHINE="${DOCKER_TOOLBOX_INSTALL_PATH}\docker-machine.exe"
  322  STEP="Looking for vboxmanage.exe"
  323  if [ ! -z "$VBOX_MSI_INSTALL_PATH" ]; then   VBOXMANAGE="${VBOX_MSI_INSTALL_PATH}VBoxManage.exe"; else   VBOXMANAGE="${VBOX_INSTALL_PATH}VBoxManage.exe"; fi
  324  BLUE='\033[1;34m'
  325  GREEN='\033[0;32m'
  326  NC='\033[0m'
  327  #clear all_proxy if not socks address
  328  if  [[ $ALL_PROXY != socks* ]]; then   unset ALL_PROXY; fi
  329  if  [[ $all_proxy != socks* ]]; then   unset all_proxy; fi
  330  if [ ! -f "${DOCKER_MACHINE}" ]; then   echo "Docker Machine is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  331  if [ ! -f "${VBOXMANAGE}" ]; then   echo "VirtualBox is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  332  "${VBOXMANAGE}" list vms | grep \""${VM}"\" &> /dev/null
  333  VM_EXISTS_CODE=$?
  334  set -e
  335  STEP="Checking if machine $VM exists"
  336  if [ $VM_EXISTS_CODE -eq 1 ]; then   "${DOCKER_MACHINE}" rm -f "${VM}" &> /dev/null || :;   rm -rf ~/.docker/machine/machines/"${VM}"   if [ "${HTTP_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTP_PROXY=$HTTP_PROXY";   fi;   if [ "${HTTPS_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTPS_PROXY=$HTTPS_PROXY";   fi;   if [ "${NO_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env NO_PROXY=$NO_PROXY";   fi;   "${DOCKER_MACHINE}" create -d virtualbox $PROXY_ENV "${VM}"; fi
  337  STEP="Checking status on $VM"
  338  VM_STATUS="$( set +e ; "${DOCKER_MACHINE}" status "${VM}" )"
  339  if [ "${VM_STATUS}" != "Running" ]; then   "${DOCKER_MACHINE}" start "${VM}";   yes | "${DOCKER_MACHINE}" regenerate-certs "${VM}"; fi
  340  STEP="Setting env"
  341  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}" | sed -e "s/export/SETX/g" | sed -e "s/=/ /g")" &> /dev/null #for persistent Environment Variables, available in next sessions
  342  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}")" #for transient Environment Variables, available in current session
  343  STEP="Finalize"
  344  clear
  345  cat << EOF
  346                          ##         .
  347                    ## ## ##        ==
  348                 ## ## ## ## ##    ===
  349             /"""""""""""""""""\___/ ===
  350        ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
  351             \______ o           __/
  352               \    \         __/
  353                \____\_______/
  354  EOF
  355  echo -e "${BLUE}docker${NC} is configured to use the ${GREEN}${VM}${NC} machine with IP ${GREEN}$("${DOCKER_MACHINE}" ip ${VM})${NC}"
  356  echo "For help getting started, check out the docs at https://docs.docker.com"
  357  echo
  358  echo 
  359  #cd #Bad: working dir should be whatever directory was invoked from rather than fixed to the Home folder
  360  docker () {   MSYS_NO_PATHCONV=1 docker.exe "$@"; }
  361  export -f docker
  362  if [ $# -eq 0 ]; then   echo "Start interactive shell";   exec "$BASH" --login -i; else   echo "Start shell with command";   exec "$BASH" -c "$*"; fi
  363  #!/bin/bash
  364  trap '[ "$?" -eq 0 ] || read -p "Looks like something went wrong in step ´$STEP´... Press any key to continue..."' EXIT
  365  #Quick Hack: used to convert e.g. "C:\Program Files\Docker Toolbox" to "/c/Program Files/Docker Toolbox"
  366  win_to_unix_path(){  	wd="$(pwd)"; 	cd "$1"; 		the_path="$(pwd)"; 	cd "$wd"; 	echo $the_path; }
  367  # This is needed  to ensure that binaries provided
  368  # by Docker Toolbox over-ride binaries provided by
  369  # Docker for Windows when launching using the Quickstart.
  370  export PATH="$(win_to_unix_path "${DOCKER_TOOLBOX_INSTALL_PATH}"):$PATH"
  371  VM=${DOCKER_MACHINE_NAME-default}
  372  DOCKER_MACHINE="${DOCKER_TOOLBOX_INSTALL_PATH}\docker-machine.exe"
  373  STEP="Looking for vboxmanage.exe"
  374  if [ ! -z "$VBOX_MSI_INSTALL_PATH" ]; then   VBOXMANAGE="${VBOX_MSI_INSTALL_PATH}VBoxManage.exe"; else   VBOXMANAGE="${VBOX_INSTALL_PATH}VBoxManage.exe"; fi
  375  BLUE='\033[1;34m'
  376  GREEN='\033[0;32m'
  377  NC='\033[0m'
  378  #clear all_proxy if not socks address
  379  if  [[ $ALL_PROXY != socks* ]]; then   unset ALL_PROXY; fi
  380  if  [[ $all_proxy != socks* ]]; then   unset all_proxy; fi
  381  if [ ! -f "${DOCKER_MACHINE}" ]; then   echo "Docker Machine is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  382  if [ ! -f "${VBOXMANAGE}" ]; then   echo "VirtualBox is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  383  "${VBOXMANAGE}" list vms | grep \""${VM}"\" &> /dev/null
  384  VM_EXISTS_CODE=$?
  385  set -e
  386  STEP="Checking if machine $VM exists"
  387  if [ $VM_EXISTS_CODE -eq 1 ]; then   "${DOCKER_MACHINE}" rm -f "${VM}" &> /dev/null || :;   rm -rf ~/.docker/machine/machines/"${VM}"   if [ "${HTTP_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTP_PROXY=$HTTP_PROXY";   fi;   if [ "${HTTPS_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTPS_PROXY=$HTTPS_PROXY";   fi;   if [ "${NO_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env NO_PROXY=$NO_PROXY";   fi;   "${DOCKER_MACHINE}" create -d virtualbox $PROXY_ENV "${VM}"; fi
  388  STEP="Checking status on $VM"
  389  VM_STATUS="$( set +e ; "${DOCKER_MACHINE}" status "${VM}" )"
  390  if [ "${VM_STATUS}" != "Running" ]; then   "${DOCKER_MACHINE}" start "${VM}";   yes | "${DOCKER_MACHINE}" regenerate-certs "${VM}"; fi
  391  STEP="Setting env"
  392  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}" | sed -e "s/export/SETX/g" | sed -e "s/=/ /g")" &> /dev/null #for persistent Environment Variables, available in next sessions
  393  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}")" #for transient Environment Variables, available in current session
  394  STEP="Finalize"
  395  clear
  396  cat << EOF
  397                          ##         .
  398                    ## ## ##        ==
  399                 ## ## ## ## ##    ===
  400             /"""""""""""""""""\___/ ===
  401        ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
  402             \______ o           __/
  403               \    \         __/
  404                \____\_______/
  405  EOF
  406  echo -e "${BLUE}docker${NC} is configured to use the ${GREEN}${VM}${NC} machine with IP ${GREEN}$("${DOCKER_MACHINE}" ip ${VM})${NC}"
  407  echo "For help getting started, check out the docs at https://docs.docker.com"
  408  echo
  409  echo 
  410  #cd #Bad: working dir should be whatever directory was invoked from rather than fixed to the Home folder
  411  docker () {   MSYS_NO_PATHCONV=1 docker.exe "$@"; }
  412  export -f docker
  413  if [ $# -eq 0 ]; then   echo "Start interactive shell";   exec "$BASH" --login -i; else   echo "Start shell with command";   exec "$BASH" -c "$*"; fi
  414  cd /c/revature/Review/training-content
  415  git pull
  416  #!/bin/bash
  417  trap '[ "$?" -eq 0 ] || read -p "Looks like something went wrong in step ´$STEP´... Press any key to continue..."' EXIT
  418  #Quick Hack: used to convert e.g. "C:\Program Files\Docker Toolbox" to "/c/Program Files/Docker Toolbox"
  419  win_to_unix_path(){  	wd="$(pwd)"; 	cd "$1"; 		the_path="$(pwd)"; 	cd "$wd"; 	echo $the_path; }
  420  # This is needed  to ensure that binaries provided
  421  # by Docker Toolbox over-ride binaries provided by
  422  # Docker for Windows when launching using the Quickstart.
  423  export PATH="$(win_to_unix_path "${DOCKER_TOOLBOX_INSTALL_PATH}"):$PATH"
  424  VM=${DOCKER_MACHINE_NAME-default}
  425  DOCKER_MACHINE="${DOCKER_TOOLBOX_INSTALL_PATH}\docker-machine.exe"
  426  STEP="Looking for vboxmanage.exe"
  427  if [ ! -z "$VBOX_MSI_INSTALL_PATH" ]; then   VBOXMANAGE="${VBOX_MSI_INSTALL_PATH}VBoxManage.exe"; else   VBOXMANAGE="${VBOX_INSTALL_PATH}VBoxManage.exe"; fi
  428  BLUE='\033[1;34m'
  429  GREEN='\033[0;32m'
  430  NC='\033[0m'
  431  #clear all_proxy if not socks address
  432  if  [[ $ALL_PROXY != socks* ]]; then   unset ALL_PROXY; fi
  433  if  [[ $all_proxy != socks* ]]; then   unset all_proxy; fi
  434  if [ ! -f "${DOCKER_MACHINE}" ]; then   echo "Docker Machine is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  435  if [ ! -f "${VBOXMANAGE}" ]; then   echo "VirtualBox is not installed. Please re-run the Toolbox Installer and try again.";   exit 1; fi
  436  "${VBOXMANAGE}" list vms | grep \""${VM}"\" &> /dev/null
  437  VM_EXISTS_CODE=$?
  438  set -e
  439  STEP="Checking if machine $VM exists"
  440  if [ $VM_EXISTS_CODE -eq 1 ]; then   "${DOCKER_MACHINE}" rm -f "${VM}" &> /dev/null || :;   rm -rf ~/.docker/machine/machines/"${VM}"   if [ "${HTTP_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTP_PROXY=$HTTP_PROXY";   fi;   if [ "${HTTPS_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env HTTPS_PROXY=$HTTPS_PROXY";   fi;   if [ "${NO_PROXY}" ]; then     PROXY_ENV="$PROXY_ENV --engine-env NO_PROXY=$NO_PROXY";   fi;   "${DOCKER_MACHINE}" create -d virtualbox $PROXY_ENV "${VM}"; fi
  441  STEP="Checking status on $VM"
  442  VM_STATUS="$( set +e ; "${DOCKER_MACHINE}" status "${VM}" )"
  443  if [ "${VM_STATUS}" != "Running" ]; then   "${DOCKER_MACHINE}" start "${VM}";   yes | "${DOCKER_MACHINE}" regenerate-certs "${VM}"; fi
  444  STEP="Setting env"
  445  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}" | sed -e "s/export/SETX/g" | sed -e "s/=/ /g")" &> /dev/null #for persistent Environment Variables, available in next sessions
  446  eval "$("${DOCKER_MACHINE}" env --shell=bash --no-proxy "${VM}")" #for transient Environment Variables, available in current session
  447  STEP="Finalize"
  448  clear
  449  cat << EOF
  450                          ##         .
  451                    ## ## ##        ==
  452                 ## ## ## ## ##    ===
  453             /"""""""""""""""""\___/ ===
  454        ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
  455             \______ o           __/
  456               \    \         __/
  457                \____\_______/
  458  EOF
  459  echo -e "${BLUE}docker${NC} is configured to use the ${GREEN}${VM}${NC} machine with IP ${GREEN}$("${DOCKER_MACHINE}" ip ${VM})${NC}"
  460  echo "For help getting started, check out the docs at https://docs.docker.com"
  461  echo
  462  echo 
  463  #cd #Bad: working dir should be whatever directory was invoked from rather than fixed to the Home folder
  464  docker () {   MSYS_NO_PATHCONV=1 docker.exe "$@"; }
  465  export -f docker
  466  if [ $# -eq 0 ]; then   echo "Start interactive shell";   exec "$BASH" --login -i; else   echo "Start shell with command";   exec "$BASH" -c "$*"; fi
  467  cd /c/revature/Review/training-content
  468  git pull
  469  cd PizzaBox
  470  dotnet run --project PizzaBox.Client/PizzaBox.Client.csproj 
  471  dotnet ef migrations add pizza-entity --project PizzaBox.Data/PizzaBox.Data.csproj --startup-project PizzaBox.Client/PizzaBox.Client.csproj --context PizzaBoxDbContext --output-dir Migrations
  472  dotnet ef migrations add pizza-entity --project PizzaBox.Data/PizzaBox.Data.csproj --startup-project PizzaBox.Client/PizzaBox.Client.csproj --context PizzaBoxDbContext --output-dir Migrations
  473  dotnet ef migrations add pizza-entity --project PizzaBox.Data/PizzaBox.Data.csproj --startup-project PizzaBox.Client/PizzaBox.Client.csproj --context PizzaBoxDbContext --output-dir Migrations
  474  dotnet ef database update --project PizzaBox.Data/PizzaBox.Data.csproj --startup-project PizzaBox.Client/PizzaBox.Client.csproj --context PizzaBoxDbContext
  475  dotnet ef migrations remove --project PizzaBox.Data/PizzaBox --starup-project PizzaBox.Client/PizzaBox.Client.csproj --context PizzaBoxDbContext
  476  dotnet ef migrations remove pizza-entity --project PizzaBox.Data/PizzaBox --starup-project PizzaBox.Client/PizzaBox.Client.csproj --context PizzaBoxDbContext
  477  dotnet ef migrations remove --project PizzaBox.Data/PizzaBox --starup-project PizzaBox.Client/PizzaBox.Client.csproj
  478  dotnet ef migrations remove --project PizzaBox.Data/PizzaBox.Data.csproj --starup-project PizzaBox.Client/PizzaBox.Client.csproj --context PizzaBoxDbContext
  479  dotnet ef migrations remove --project PizzaBox.Data/PizzaBox.Data.csproj --startup-project PizzaBox.Client/PizzaBox.Client.csproj --context PizzaBoxDbContext
  480  dotnet ef migrations remove --project PizzaBox.Data/PizzaBox.Data.csproj --startup-project PizzaBox.Client/PizzaBox.Client.csproj
  481  dotnet ef migrations remove pizza-entity --project PizzaBox.Data/PizzaBox.Data.csproj --startup-project PizzaBox.Client/PizzaBox.Client.csproj --context PizzaBoxDbContext
  482  dotnet ef migrations remove
  483  dotnet ef migrations remove --project PizzaBox.Data/PizzaBox.Data.csproj 
  484  dotnet ef migrations remove --project PizzaBox.Data/PizzaBox.Data.csproj --startup-project PizzaBox.Client/PizzaBox.Client.csproj 
  485  dotnet ef migrations remove --project PizzaBox.Data/PizzaBox.Data.csproj --startup-project PizzaBox.Client/PizzaBox.Client.csproj --context PizzaBoxDbContext --output-dir Migrations
  486  history > hist.txt
